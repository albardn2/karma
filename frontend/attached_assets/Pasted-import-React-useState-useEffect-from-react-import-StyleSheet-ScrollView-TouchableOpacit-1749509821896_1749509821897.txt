import React, { useState, useEffect } from 'react';
import { StyleSheet, ScrollView, TouchableOpacity, Alert, ActivityIndicator, View, Dimensions, Platform, TextInput, Animated } from 'react-native';
import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { apiCall } from '@/utils/api';
import { LinearGradient } from 'expo-linear-gradient';

// Disable the native header
export const options = { headerShown: false };

interface Customer {
  uuid: string;
  email_address: string | null;
  company_name: string;
  full_name: string;
  phone_number: string;
  full_address: string;
  business_cards: string | null;
  notes: string | null;
  category: 'roastery' | 'restaurant' | 'minimarket' | 'supermarket' | 'distributer';
  coordinates: string | null;
  created_at: string;
  is_deleted: boolean;
  balance_per_currency: Record<string, number>;
}

export default function CustomerDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const router = useRouter();
  const [customer, setCustomer] = useState<Customer | null>(null);
  const [loading, setLoading] = useState(true);
  const [screenData, setScreenData] = useState(Dimensions.get('window'));
  const [isEditing, setIsEditing] = useState(false);
  const [editedCustomer, setEditedCustomer] = useState<Customer | null>(null);
  const [updating, setUpdating] = useState(false);
  const [banner, setBanner] = useState<{type: 'success' | 'error', message: string} | null>(null);
  const bannerAnimation = useState(new Animated.Value(0))[0];
  const [errors, setErrors] = useState<Partial<Record<string, string>>>({});

  useEffect(() => {
    const sub = Dimensions.addEventListener('change', ({ window }) => setScreenData(window));
    return () => sub?.remove();
  }, []);

  useEffect(() => {
    if (id) fetchCustomer();
  }, [id]);

  const showBanner = (type: 'success' | 'error', message: string) => {
    setBanner({ type, message });
    Animated.sequence([
      Animated.timing(bannerAnimation, { toValue: 1, duration: 300, useNativeDriver: true }),
      Animated.delay(3000),
      Animated.timing(bannerAnimation, { toValue: 0, duration: 300, useNativeDriver: true }),
    ]).start(() => setBanner(null));
  };

  const validateForm = (): boolean => {
    if (!editedCustomer) return false;
    const newErrors: Record<string, string> = {};
    if (!editedCustomer.full_name.trim()) newErrors.full_name = 'Customer name is required';
    if (!editedCustomer.company_name.trim()) newErrors.company_name = 'Company name is required';
    const hasPhone = editedCustomer.phone_number.trim().length > 0;
    const hasEmail = editedCustomer.email_address?.trim().length > 0;
    if (!hasPhone && !hasEmail) {
      newErrors.phone_number = newErrors.email_address = 'Either phone or email is required';
    }
    if (editedCustomer.email_address?.trim() && !/\S+@\S+\.\S+/.test(editedCustomer.email_address)) {
      newErrors.email_address = 'Please enter a valid email';
    }
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const fetchCustomer = async () => {
    setLoading(true);
    try {
      const response = await apiCall<Customer>(`/customer/${id}`);
      if (response.status === 200 && response.data) {
        setCustomer(response.data);
        setEditedCustomer(response.data);
      } else {
        Alert.alert('Error', 'Failed to load customer');
        router.back();
      }
    } catch {
      Alert.alert('Error', 'Failed to load customer');
      router.back();
    } finally {
      setLoading(false);
    }
  };

  const handleEdit = () => setIsEditing(true);
  const handleCancelEdit = () => {
    setIsEditing(false);
    setEditedCustomer(customer);
    setErrors({});
  };

  const handleSaveEdit = async () => {
    if (!editedCustomer || !customer) return;
    if (!validateForm()) { showBanner('error', 'Please fix validation errors'); return; }
    setUpdating(true);
    try {
      const updateData: Partial<Customer> = {};
      (Object.keys(editedCustomer) as (keyof Customer)[]).forEach(key => {
        if ((editedCustomer as any)[key] !== (customer as any)[key]) {
          (updateData as any)[key] = (editedCustomer as any)[key];
        }
      });
      if (!Object.keys(updateData).length) { setIsEditing(false); showBanner('success', 'No changes made'); return; }
      const resp = await apiCall(`/customer/${id}`, { method: 'PUT', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(updateData) });
      if (resp.status === 200 && resp.data) {
        setCustomer(resp.data);
        setEditedCustomer(resp.data);
        setIsEditing(false);
        setErrors({});
        showBanner('success', 'Customer updated successfully!');
      } else {
        let errMsg = 'Failed to update';
        if (resp.error) { try { errMsg = JSON.parse(resp.error).detail || errMsg; } catch {} }
        showBanner('error', errMsg);
      }
    } catch { showBanner('error', 'Network error'); }
    finally { setUpdating(false); }
  };

  const handleDelete = () => {
    Alert.alert('Delete Customer', 'Are you sure you want to delete this customer? This action cannot be undone.', [
      { text: 'Cancel', style: 'cancel' },
      { text: 'Delete', style: 'destructive', onPress: confirmDelete }
    ]);
  };

  const confirmDelete = async () => {
    setLoading(true);
    try {
      const resp = await apiCall(`/customer/${id}`, { method: 'DELETE' });
      if (resp.status === 200) router.replace('/customers');
      else Alert.alert('Error', 'Failed to delete');
    } catch { Alert.alert('Error', 'Failed to delete'); }
    finally { setLoading(false); }
  };

  const formatDate = (d: string) => new Date(d).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
  const getTotalBalance = () => customer ? Object.values(customer.balance_per_currency).reduce((a,b)=>a+b,0) : 0;
  const getBalanceColor = (bal: number) => bal>0?'#10b981':bal<0?'#ef4444':'#6b7280';

  if (loading) return (<ThemedView style={styles.container}><ActivityIndicator size="large" color="#5469D4" /></ThemedView>);
  if (!customer) return (<ThemedView style={styles.container}><ThemedText style={styles.errorText}>Customer not found</ThemedText></ThemedView>);

  const InfoRow = ({ label, value, editable=false, multiline=false, keyboardType='default', fieldName }: any) => (
    <View style={styles.infoRow}>
      <ThemedText style={styles.infoLabel}>{label}</ThemedText>
      {isEditing && editable && fieldName ? (
        <> <TextInput
            style={[styles.infoInput, multiline && styles.infoInputMultiline, errors[fieldName] && styles.inputError]}
            value={value}
            onChangeText={text => { setEditedCustomer(prev=>prev?{...prev,[fieldName]:text}:null); setErrors(prev => ({...prev, [fieldName]:''})); }}
            multiline={multiline}
            keyboardType={keyboardType}
            placeholderTextColor="#9ca3af"
          />
          {errors[fieldName] && <ThemedText style={styles.errorText}>{errors[fieldName]}</ThemedText>}
        </>
      ) : (
        <ThemedText style={styles.infoValue}>{value || 'Not provided'}</ThemedText>
      )}
    </View>
  );

  return (
    <ThemedView style={styles.container}>
      {banner && (
        <Animated.View style={[styles.banner, banner.type==='success'?styles.successBanner:styles.errorBanner, {opacity:bannerAnimation, transform:[{translateY:bannerAnimation.interpolate({inputRange:[0,1],outputRange:[-100,0]})}]}]}>
          <ThemedText style={styles.bannerText}>{banner.message}</ThemedText>
        </Animated.View>
      )}

      <ScrollView style={styles.scrollView} contentContainerStyle={[styles.content, isDesktop && styles.desktopContent]}>        
        {/* Contact Information */}
        <View style={styles.section}>
          <ThemedText style={styles.sectionTitle}>Contact Information</ThemedText>
          <View style={styles.sectionContent}>
            <InfoRow label="Full Name" value={editedCustomer?.full_name||customer.full_name} editable fieldName="full_name" />
            <InfoRow label="Company Name" value={editedCustomer?.company_name||customer.company_name} editable fieldName="company_name" />
            <InfoRow label="Email Address" value={editedCustomer?.email_address||customer.email_address||''} editable keyboardType="email-address" fieldName="email_address" />
            <InfoRow label="Phone Number" value={editedCustomer?.phone_number||customer.phone_number} editable keyboardType="phone-pad" fieldName="phone_number" />
            <InfoRow label="Full Address" value={editedCustomer?.full_address||customer.full_address} editable multiline fieldName="full_address" />
          </View>
        </View>

        {/* Business Details */}
        <View style={styles.section}>
          <ThemedText style={styles.sectionTitle}>Business Details</ThemedText>
          <View style={styles.sectionContent}>
            <InfoRow label="Business Cards" value={editedCustomer?.business_cards||customer.business_cards||''} editable multiline fieldName="business_cards" />
            <InfoRow label="Notes" value={editedCustomer?.notes||customer.notes||''} editable multiline fieldName="notes" />
            <InfoRow label="Coordinates" value={editedCustomer?.coordinates||customer.coordinates||''} editable fieldName="coordinates" />
            <InfoRow label="UUID" value={customer.uuid} />
            <InfoRow label="Created" value={formatDate(customer.created_at)} />
          </View>
        </View>

        {/* Balance Details */}
        <View style={styles.section}>
          <ThemedText style={styles.sectionTitle}>Balance Details</ThemedText>
          <View style={styles.sectionContent}>
            {Object.entries(customer.balance_per_currency).length>0 ? Object.entries(customer.balance_per_currency).map(([currency, amount]) => (
              <View key={currency} style={styles.balanceRow}>
                <ThemedText style={styles.currencyLabel}>{currency.toUpperCase()}</ThemedText>
                <ThemedText style={[styles.currencyAmount, { color: getBalanceColor(amount) }]}>
                  {amount.toFixed(2)}
                </ThemedText>
              </View>
            )) : (
              <ThemedText style={styles.noBalanceText}>No balance information available</ThemedText>
            )}
          </View>
        </View>
      </ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({ /* unchanged styles */ });
